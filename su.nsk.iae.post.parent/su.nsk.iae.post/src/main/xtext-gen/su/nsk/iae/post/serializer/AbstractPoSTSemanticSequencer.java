/*
 * generated by Xtext 2.25.0
 */
package su.nsk.iae.post.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import su.nsk.iae.post.poST.AddExpression;
import su.nsk.iae.post.poST.AndExpression;
import su.nsk.iae.post.poST.ArrayInitialization;
import su.nsk.iae.post.poST.ArrayInterval;
import su.nsk.iae.post.poST.ArraySpecification;
import su.nsk.iae.post.poST.ArraySpecificationInit;
import su.nsk.iae.post.poST.ArrayVariable;
import su.nsk.iae.post.poST.AssignmentStatement;
import su.nsk.iae.post.poST.AttachVariableConfElement;
import su.nsk.iae.post.poST.CaseElement;
import su.nsk.iae.post.poST.CaseList;
import su.nsk.iae.post.poST.CaseListElement;
import su.nsk.iae.post.poST.CaseStatement;
import su.nsk.iae.post.poST.CompExpression;
import su.nsk.iae.post.poST.Configuration;
import su.nsk.iae.post.poST.Constant;
import su.nsk.iae.post.poST.EquExpression;
import su.nsk.iae.post.poST.ErrorProcessStatement;
import su.nsk.iae.post.poST.ExitStatement;
import su.nsk.iae.post.poST.Expression;
import su.nsk.iae.post.poST.ExternalVarDeclaration;
import su.nsk.iae.post.poST.ExternalVarInitDeclaration;
import su.nsk.iae.post.poST.FBInvocation;
import su.nsk.iae.post.poST.ForList;
import su.nsk.iae.post.poST.ForStatement;
import su.nsk.iae.post.poST.Function;
import su.nsk.iae.post.poST.FunctionBlock;
import su.nsk.iae.post.poST.FunctionCall;
import su.nsk.iae.post.poST.GlobalVarDeclaration;
import su.nsk.iae.post.poST.GlobalVarInitDeclaration;
import su.nsk.iae.post.poST.IfStatement;
import su.nsk.iae.post.poST.InputOutputVarDeclaration;
import su.nsk.iae.post.poST.InputVarDeclaration;
import su.nsk.iae.post.poST.IntegerLiteral;
import su.nsk.iae.post.poST.Model;
import su.nsk.iae.post.poST.MulExpression;
import su.nsk.iae.post.poST.OutputVarDeclaration;
import su.nsk.iae.post.poST.ParamAssignment;
import su.nsk.iae.post.poST.ParamAssignmentElements;
import su.nsk.iae.post.poST.PoSTPackage;
import su.nsk.iae.post.poST.PowerExpression;
import su.nsk.iae.post.poST.PrimaryExpression;
import su.nsk.iae.post.poST.ProcessStatusExpression;
import su.nsk.iae.post.poST.ProcessVarDeclaration;
import su.nsk.iae.post.poST.ProcessVarInitDeclaration;
import su.nsk.iae.post.poST.ProcessVarList;
import su.nsk.iae.post.poST.ProcessVariable;
import su.nsk.iae.post.poST.Program;
import su.nsk.iae.post.poST.ProgramConfElements;
import su.nsk.iae.post.poST.ProgramConfiguration;
import su.nsk.iae.post.poST.RealLiteral;
import su.nsk.iae.post.poST.RepeatStatement;
import su.nsk.iae.post.poST.ResetTimerStatement;
import su.nsk.iae.post.poST.Resource;
import su.nsk.iae.post.poST.SetStateStatement;
import su.nsk.iae.post.poST.SignedInteger;
import su.nsk.iae.post.poST.SimpleSpecificationInit;
import su.nsk.iae.post.poST.SingleResource;
import su.nsk.iae.post.poST.StartProcessStatement;
import su.nsk.iae.post.poST.State;
import su.nsk.iae.post.poST.StatementList;
import su.nsk.iae.post.poST.StopProcessStatement;
import su.nsk.iae.post.poST.SubprogramControlStatement;
import su.nsk.iae.post.poST.SymbolicVariable;
import su.nsk.iae.post.poST.Task;
import su.nsk.iae.post.poST.TaskInitialization;
import su.nsk.iae.post.poST.TempVarDeclaration;
import su.nsk.iae.post.poST.TemplateProcessAttachVariableConfElement;
import su.nsk.iae.post.poST.TemplateProcessConfElement;
import su.nsk.iae.post.poST.TemplateProcessElements;
import su.nsk.iae.post.poST.TimeLiteral;
import su.nsk.iae.post.poST.TimeoutStatement;
import su.nsk.iae.post.poST.UnaryExpression;
import su.nsk.iae.post.poST.VarDeclaration;
import su.nsk.iae.post.poST.VarInitDeclaration;
import su.nsk.iae.post.poST.VarList;
import su.nsk.iae.post.poST.WhileStatement;
import su.nsk.iae.post.poST.XorExpression;
import su.nsk.iae.post.services.PoSTGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractPoSTSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PoSTGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PoSTPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PoSTPackage.ADD_EXPRESSION:
				sequence_AddExpression(context, (AddExpression) semanticObject); 
				return; 
			case PoSTPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case PoSTPackage.ARRAY_INITIALIZATION:
				sequence_ArrayInitialization(context, (ArrayInitialization) semanticObject); 
				return; 
			case PoSTPackage.ARRAY_INTERVAL:
				sequence_ArrayInterval(context, (ArrayInterval) semanticObject); 
				return; 
			case PoSTPackage.ARRAY_SPECIFICATION:
				sequence_ArraySpecification(context, (ArraySpecification) semanticObject); 
				return; 
			case PoSTPackage.ARRAY_SPECIFICATION_INIT:
				sequence_ArraySpecificationInit(context, (ArraySpecificationInit) semanticObject); 
				return; 
			case PoSTPackage.ARRAY_VARIABLE:
				sequence_ArrayVariable(context, (ArrayVariable) semanticObject); 
				return; 
			case PoSTPackage.ASSIGNMENT_STATEMENT:
				sequence_AssignmentStatement(context, (AssignmentStatement) semanticObject); 
				return; 
			case PoSTPackage.ATTACH_VARIABLE_CONF_ELEMENT:
				sequence_AttachVariableConfElement(context, (AttachVariableConfElement) semanticObject); 
				return; 
			case PoSTPackage.CASE_ELEMENT:
				sequence_CaseElement(context, (CaseElement) semanticObject); 
				return; 
			case PoSTPackage.CASE_LIST:
				sequence_CaseList(context, (CaseList) semanticObject); 
				return; 
			case PoSTPackage.CASE_LIST_ELEMENT:
				sequence_CaseListElement(context, (CaseListElement) semanticObject); 
				return; 
			case PoSTPackage.CASE_STATEMENT:
				sequence_CaseStatement(context, (CaseStatement) semanticObject); 
				return; 
			case PoSTPackage.COMP_EXPRESSION:
				sequence_CompExpression(context, (CompExpression) semanticObject); 
				return; 
			case PoSTPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case PoSTPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case PoSTPackage.EQU_EXPRESSION:
				sequence_EquExpression(context, (EquExpression) semanticObject); 
				return; 
			case PoSTPackage.ERROR_PROCESS_STATEMENT:
				sequence_ErrorProcessStatement(context, (ErrorProcessStatement) semanticObject); 
				return; 
			case PoSTPackage.EXIT_STATEMENT:
				sequence_ExitStatement(context, (ExitStatement) semanticObject); 
				return; 
			case PoSTPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case PoSTPackage.EXTERNAL_VAR_DECLARATION:
				sequence_ExternalVarDeclaration(context, (ExternalVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.EXTERNAL_VAR_INIT_DECLARATION:
				sequence_ExternalVarInitDeclaration(context, (ExternalVarInitDeclaration) semanticObject); 
				return; 
			case PoSTPackage.FB_INVOCATION:
				sequence_FBInvocation(context, (FBInvocation) semanticObject); 
				return; 
			case PoSTPackage.FOR_LIST:
				sequence_ForList(context, (ForList) semanticObject); 
				return; 
			case PoSTPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case PoSTPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case PoSTPackage.FUNCTION_BLOCK:
				sequence_FunctionBlock(context, (FunctionBlock) semanticObject); 
				return; 
			case PoSTPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case PoSTPackage.GLOBAL_VAR_DECLARATION:
				sequence_GlobalVarDeclaration(context, (GlobalVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.GLOBAL_VAR_INIT_DECLARATION:
				sequence_GlobalVarInitDeclaration(context, (GlobalVarInitDeclaration) semanticObject); 
				return; 
			case PoSTPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case PoSTPackage.INPUT_OUTPUT_VAR_DECLARATION:
				sequence_InputOutputVarDeclaration(context, (InputOutputVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.INPUT_VAR_DECLARATION:
				sequence_InputVarDeclaration(context, (InputVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case PoSTPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case PoSTPackage.MUL_EXPRESSION:
				sequence_MulExpression(context, (MulExpression) semanticObject); 
				return; 
			case PoSTPackage.OUTPUT_VAR_DECLARATION:
				sequence_OutputVarDeclaration(context, (OutputVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.PARAM_ASSIGNMENT:
				sequence_ParamAssignment(context, (ParamAssignment) semanticObject); 
				return; 
			case PoSTPackage.PARAM_ASSIGNMENT_ELEMENTS:
				sequence_ParamAssignmentElements(context, (ParamAssignmentElements) semanticObject); 
				return; 
			case PoSTPackage.POWER_EXPRESSION:
				sequence_PowerExpression(context, (PowerExpression) semanticObject); 
				return; 
			case PoSTPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case PoSTPackage.PROCESS:
				sequence_Process(context, (su.nsk.iae.post.poST.Process) semanticObject); 
				return; 
			case PoSTPackage.PROCESS_STATUS_EXPRESSION:
				sequence_ProcessStatusExpression(context, (ProcessStatusExpression) semanticObject); 
				return; 
			case PoSTPackage.PROCESS_VAR_DECLARATION:
				sequence_ProcessVarDeclaration(context, (ProcessVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.PROCESS_VAR_INIT_DECLARATION:
				sequence_ProcessVarInitDeclaration(context, (ProcessVarInitDeclaration) semanticObject); 
				return; 
			case PoSTPackage.PROCESS_VAR_LIST:
				sequence_ProcessVarList(context, (ProcessVarList) semanticObject); 
				return; 
			case PoSTPackage.PROCESS_VARIABLE:
				sequence_ProcessVariable(context, (ProcessVariable) semanticObject); 
				return; 
			case PoSTPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case PoSTPackage.PROGRAM_CONF_ELEMENTS:
				sequence_ProgramConfElements(context, (ProgramConfElements) semanticObject); 
				return; 
			case PoSTPackage.PROGRAM_CONFIGURATION:
				sequence_ProgramConfiguration(context, (ProgramConfiguration) semanticObject); 
				return; 
			case PoSTPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case PoSTPackage.REPEAT_STATEMENT:
				sequence_RepeatStatement(context, (RepeatStatement) semanticObject); 
				return; 
			case PoSTPackage.RESET_TIMER_STATEMENT:
				sequence_ResetTimerStatement(context, (ResetTimerStatement) semanticObject); 
				return; 
			case PoSTPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case PoSTPackage.SET_STATE_STATEMENT:
				sequence_SetStateStatement(context, (SetStateStatement) semanticObject); 
				return; 
			case PoSTPackage.SIGNED_INTEGER:
				sequence_SignedInteger(context, (SignedInteger) semanticObject); 
				return; 
			case PoSTPackage.SIMPLE_SPECIFICATION_INIT:
				sequence_SimpleSpecificationInit(context, (SimpleSpecificationInit) semanticObject); 
				return; 
			case PoSTPackage.SINGLE_RESOURCE:
				sequence_SingleResource(context, (SingleResource) semanticObject); 
				return; 
			case PoSTPackage.START_PROCESS_STATEMENT:
				sequence_StartProcessStatement(context, (StartProcessStatement) semanticObject); 
				return; 
			case PoSTPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case PoSTPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case PoSTPackage.STOP_PROCESS_STATEMENT:
				sequence_StopProcessStatement(context, (StopProcessStatement) semanticObject); 
				return; 
			case PoSTPackage.SUBPROGRAM_CONTROL_STATEMENT:
				sequence_SubprogramControlStatement(context, (SubprogramControlStatement) semanticObject); 
				return; 
			case PoSTPackage.SYMBOLIC_VARIABLE:
				sequence_SymbolicVariable(context, (SymbolicVariable) semanticObject); 
				return; 
			case PoSTPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case PoSTPackage.TASK_INITIALIZATION:
				sequence_TaskInitialization(context, (TaskInitialization) semanticObject); 
				return; 
			case PoSTPackage.TEMP_VAR_DECLARATION:
				sequence_TempVarDeclaration(context, (TempVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.TEMPLATE_PROCESS_ATTACH_VARIABLE_CONF_ELEMENT:
				sequence_TemplateProcessAttachVariableConfElement(context, (TemplateProcessAttachVariableConfElement) semanticObject); 
				return; 
			case PoSTPackage.TEMPLATE_PROCESS_CONF_ELEMENT:
				sequence_TemplateProcessConfElement(context, (TemplateProcessConfElement) semanticObject); 
				return; 
			case PoSTPackage.TEMPLATE_PROCESS_ELEMENTS:
				sequence_TemplateProcessElements(context, (TemplateProcessElements) semanticObject); 
				return; 
			case PoSTPackage.TIME_LITERAL:
				sequence_TimeLiteral(context, (TimeLiteral) semanticObject); 
				return; 
			case PoSTPackage.TIMEOUT_STATEMENT:
				sequence_TimeoutStatement(context, (TimeoutStatement) semanticObject); 
				return; 
			case PoSTPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case PoSTPackage.VAR_DECLARATION:
				sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.VAR_INIT_DECLARATION:
				sequence_VarInitDeclaration(context, (VarInitDeclaration) semanticObject); 
				return; 
			case PoSTPackage.VAR_LIST:
				sequence_VarList(context, (VarList) semanticObject); 
				return; 
			case PoSTPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			case PoSTPackage.XOR_EXPRESSION:
				sequence_XorExpression(context, (XorExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AddExpression
	 *     Expression.Expression_1_0 returns AddExpression
	 *     XorExpression returns AddExpression
	 *     XorExpression.XorExpression_1_0 returns AddExpression
	 *     AndExpression returns AddExpression
	 *     AndExpression.AndExpression_1_0 returns AddExpression
	 *     CompExpression returns AddExpression
	 *     CompExpression.CompExpression_1_0 returns AddExpression
	 *     EquExpression returns AddExpression
	 *     EquExpression.EquExpression_1_0 returns AddExpression
	 *     AddExpression returns AddExpression
	 *     AddExpression.AddExpression_1_0 returns AddExpression
	 *
	 * Constraint:
	 *     (left=AddExpression_AddExpression_1_0 addOp=AddOperator right=MulExpression)
	 */
	protected void sequence_AddExpression(ISerializationContext context, AddExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ADD_EXPRESSION__ADD_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ADD_EXPRESSION__ADD_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddExpressionAccess().getAddExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddExpressionAccess().getAddOpAddOperatorEnumRuleCall_1_1_0(), semanticObject.getAddOp());
		feeder.accept(grammarAccess.getAddExpressionAccess().getRightMulExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     Expression.Expression_1_0 returns AndExpression
	 *     XorExpression returns AndExpression
	 *     XorExpression.XorExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=CompExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightCompExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArrayInitialization returns ArrayInitialization
	 *
	 * Constraint:
	 *     (elements+=Expression elements+=Expression*)
	 */
	protected void sequence_ArrayInitialization(ISerializationContext context, ArrayInitialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayInterval returns ArrayInterval
	 *
	 * Constraint:
	 *     (start=Expression end=Expression)
	 */
	protected void sequence_ArrayInterval(ISerializationContext context, ArrayInterval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ARRAY_INTERVAL__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ARRAY_INTERVAL__START));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ARRAY_INTERVAL__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ARRAY_INTERVAL__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayIntervalAccess().getStartExpressionParserRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getArrayIntervalAccess().getEndExpressionParserRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArraySpecificationInit returns ArraySpecificationInit
	 *
	 * Constraint:
	 *     (init=ArraySpecification values=ArrayInitialization?)
	 */
	protected void sequence_ArraySpecificationInit(ISerializationContext context, ArraySpecificationInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArraySpecification returns ArraySpecification
	 *
	 * Constraint:
	 *     (interval=ArrayInterval? type=DataTypeName)
	 */
	protected void sequence_ArraySpecification(ISerializationContext context, ArraySpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayVariable returns ArrayVariable
	 *
	 * Constraint:
	 *     (variable=[SymbolicVariable|ID] index=Expression)
	 */
	protected void sequence_ArrayVariable(ISerializationContext context, ArrayVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ARRAY_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ARRAY_VARIABLE__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ARRAY_VARIABLE__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ARRAY_VARIABLE__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayVariableAccess().getVariableSymbolicVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(PoSTPackage.Literals.ARRAY_VARIABLE__VARIABLE, false));
		feeder.accept(grammarAccess.getArrayVariableAccess().getIndexExpressionParserRuleCall_2_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssignmentStatement
	 *     AssignmentStatement returns AssignmentStatement
	 *
	 * Constraint:
	 *     ((variable=[SymbolicVariable|ID] | array=ArrayVariable) value=Expression)
	 */
	protected void sequence_AssignmentStatement(ISerializationContext context, AssignmentStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramConfElement returns AttachVariableConfElement
	 *     AttachVariableConfElement returns AttachVariableConfElement
	 *
	 * Constraint:
	 *     (programVar=[SymbolicVariable|ID] assig=AssignmentType (attVar=[SymbolicVariable|ID] | const=Constant))
	 */
	protected void sequence_AttachVariableConfElement(ISerializationContext context, AttachVariableConfElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseElement returns CaseElement
	 *
	 * Constraint:
	 *     (caseList=CaseList statement=StatementList)
	 */
	protected void sequence_CaseElement(ISerializationContext context, CaseElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.CASE_ELEMENT__CASE_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.CASE_ELEMENT__CASE_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.CASE_ELEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.CASE_ELEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseElementAccess().getCaseListCaseListParserRuleCall_0_0(), semanticObject.getCaseList());
		feeder.accept(grammarAccess.getCaseElementAccess().getStatementStatementListParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseListElement returns CaseListElement
	 *
	 * Constraint:
	 *     (num=SignedInteger | variable=[SymbolicVariable|ID])
	 */
	protected void sequence_CaseListElement(ISerializationContext context, CaseListElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseList returns CaseList
	 *
	 * Constraint:
	 *     (caseListElement+=CaseListElement caseListElement+=CaseListElement*)
	 */
	protected void sequence_CaseList(ISerializationContext context, CaseList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CaseStatement
	 *     SelectionStatement returns CaseStatement
	 *     CaseStatement returns CaseStatement
	 *
	 * Constraint:
	 *     (cond=Expression caseElements+=CaseElement* elseStatement=StatementList?)
	 */
	protected void sequence_CaseStatement(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CompExpression
	 *     Expression.Expression_1_0 returns CompExpression
	 *     XorExpression returns CompExpression
	 *     XorExpression.XorExpression_1_0 returns CompExpression
	 *     AndExpression returns CompExpression
	 *     AndExpression.AndExpression_1_0 returns CompExpression
	 *     CompExpression returns CompExpression
	 *     CompExpression.CompExpression_1_0 returns CompExpression
	 *
	 * Constraint:
	 *     (left=CompExpression_CompExpression_1_0 compOp=CompOperator right=EquExpression)
	 */
	protected void sequence_CompExpression(ISerializationContext context, CompExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.COMP_EXPRESSION__COMP_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.COMP_EXPRESSION__COMP_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompExpressionAccess().getCompExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompExpressionAccess().getCompOpCompOperatorEnumRuleCall_1_1_0(), semanticObject.getCompOp());
		feeder.accept(grammarAccess.getCompExpressionAccess().getRightEquExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (name=ID (confGlobVars+=GlobalVarDeclaration | resources+=Resource)*)
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     (
	 *         num=NumericLiteral | 
	 *         time=TimeLiteral | 
	 *         oth=BINARY_INTEGER | 
	 *         oth=OCTAL_INTEGER | 
	 *         oth=HEX_INTEGER | 
	 *         oth=BOOLEAN_LITERAL
	 *     )
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EquExpression
	 *     Expression.Expression_1_0 returns EquExpression
	 *     XorExpression returns EquExpression
	 *     XorExpression.XorExpression_1_0 returns EquExpression
	 *     AndExpression returns EquExpression
	 *     AndExpression.AndExpression_1_0 returns EquExpression
	 *     CompExpression returns EquExpression
	 *     CompExpression.CompExpression_1_0 returns EquExpression
	 *     EquExpression returns EquExpression
	 *     EquExpression.EquExpression_1_0 returns EquExpression
	 *
	 * Constraint:
	 *     (left=EquExpression_EquExpression_1_0 equOp=EquOperator right=AddExpression)
	 */
	protected void sequence_EquExpression(ISerializationContext context, EquExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EQU_EXPRESSION__EQU_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EQU_EXPRESSION__EQU_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquExpressionAccess().getEquExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquExpressionAccess().getEquOpEquOperatorEnumRuleCall_1_1_0(), semanticObject.getEquOp());
		feeder.accept(grammarAccess.getEquExpressionAccess().getRightAddExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatements returns ErrorProcessStatement
	 *     ErrorProcessStatement returns ErrorProcessStatement
	 *     Statement returns ErrorProcessStatement
	 *
	 * Constraint:
	 *     process=[Variable|ID]?
	 */
	protected void sequence_ErrorProcessStatement(ISerializationContext context, ErrorProcessStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExitStatement
	 *     ExitStatement returns ExitStatement
	 *
	 * Constraint:
	 *     {ExitStatement}
	 */
	protected void sequence_ExitStatement(ISerializationContext context, ExitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Expression.Expression_1_0 returns Expression
	 *
	 * Constraint:
	 *     (left=Expression_Expression_1_0 right=XorExpression)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightXorExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExternalVarDeclaration returns ExternalVarDeclaration
	 *
	 * Constraint:
	 *     (const?='CONSTANT'? vars+=ExternalVarInitDeclaration*)
	 */
	protected void sequence_ExternalVarDeclaration(ISerializationContext context, ExternalVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExternalVarInitDeclaration returns ExternalVarInitDeclaration
	 *
	 * Constraint:
	 *     (varList=VarList type=DataTypeName)
	 */
	protected void sequence_ExternalVarInitDeclaration(ISerializationContext context, ExternalVarInitDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXTERNAL_VAR_INIT_DECLARATION__VAR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXTERNAL_VAR_INIT_DECLARATION__VAR_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXTERNAL_VAR_INIT_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXTERNAL_VAR_INIT_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalVarInitDeclarationAccess().getVarListVarListParserRuleCall_0_0(), semanticObject.getVarList());
		feeder.accept(grammarAccess.getExternalVarInitDeclarationAccess().getTypeDataTypeNameParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FBInvocation returns FBInvocation
	 *     Statement returns FBInvocation
	 *
	 * Constraint:
	 *     (fb=[SymbolicVariable|ID] args=ParamAssignmentElements?)
	 */
	protected void sequence_FBInvocation(ISerializationContext context, FBInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForList returns ForList
	 *
	 * Constraint:
	 *     (start=Expression end=Expression step=Expression?)
	 */
	protected void sequence_ForList(ISerializationContext context, ForList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     IterationStatement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (variable=[SymbolicVariable|ID] forList=ForList statement=StatementList)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.FOR_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.FOR_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.FOR_STATEMENT__FOR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.FOR_STATEMENT__FOR_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getVariableSymbolicVariableIDTerminalRuleCall_1_0_1(), semanticObject.eGet(PoSTPackage.Literals.FOR_STATEMENT__VARIABLE, false));
		feeder.accept(grammarAccess.getForStatementAccess().getForListForListParserRuleCall_3_0(), semanticObject.getForList());
		feeder.accept(grammarAccess.getForStatementAccess().getStatementStatementListParserRuleCall_5_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBlock returns FunctionBlock
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             fbInVars+=InputVarDeclaration | 
	 *             fbOutVars+=OutputVarDeclaration | 
	 *             fbInOutVars+=InputOutputVarDeclaration | 
	 *             fbVars+=VarDeclaration | 
	 *             fbTempVars+=TempVarDeclaration | 
	 *             fbExternVars+=ExternalVarDeclaration
	 *         )* 
	 *         processes+=Process*
	 *     )
	 */
	protected void sequence_FunctionBlock(ISerializationContext context, FunctionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (function=[Function|ID] args=ParamAssignmentElements?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=DataTypeName 
	 *         (funInVars+=InputVarDeclaration | funOutVars+=OutputVarDeclaration | funInOutVars+=InputOutputVarDeclaration | funVars+=VarDeclaration)* 
	 *         statement=StatementList
	 *     )
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVarDeclaration returns GlobalVarDeclaration
	 *
	 * Constraint:
	 *     (const?='CONSTANT'? (varsSimple+=VarInitDeclaration | varsAs+=GlobalVarInitDeclaration)*)
	 */
	protected void sequence_GlobalVarDeclaration(ISerializationContext context, GlobalVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVarInitDeclaration returns GlobalVarInitDeclaration
	 *
	 * Constraint:
	 *     (varList=VarList location=DIRECT_VARIABLE type=DataTypeName)
	 */
	protected void sequence_GlobalVarInitDeclaration(ISerializationContext context, GlobalVarInitDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__VAR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__VAR_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__LOCATION));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalVarInitDeclarationAccess().getVarListVarListParserRuleCall_0_0(), semanticObject.getVarList());
		feeder.accept(grammarAccess.getGlobalVarInitDeclarationAccess().getLocationDIRECT_VARIABLETerminalRuleCall_2_0(), semanticObject.getLocation());
		feeder.accept(grammarAccess.getGlobalVarInitDeclarationAccess().getTypeDataTypeNameParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     SelectionStatement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (mainCond=Expression mainStatement=StatementList (elseIfCond+=Expression elseIfStatements+=StatementList)* elseStatement=StatementList?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputOutputVarDeclaration returns InputOutputVarDeclaration
	 *
	 * Constraint:
	 *     vars+=VarInitDeclaration*
	 */
	protected void sequence_InputOutputVarDeclaration(ISerializationContext context, InputOutputVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputVarDeclaration returns InputVarDeclaration
	 *
	 * Constraint:
	 *     vars+=VarInitDeclaration*
	 */
	protected void sequence_InputVarDeclaration(ISerializationContext context, InputVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericLiteral returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     (type=IntegerTypeName? value=SignedInteger)
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (conf=Configuration | globVars+=GlobalVarDeclaration | programs+=Program | fbs+=FunctionBlock | funs+=Function)+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulExpression
	 *     Expression.Expression_1_0 returns MulExpression
	 *     XorExpression returns MulExpression
	 *     XorExpression.XorExpression_1_0 returns MulExpression
	 *     AndExpression returns MulExpression
	 *     AndExpression.AndExpression_1_0 returns MulExpression
	 *     CompExpression returns MulExpression
	 *     CompExpression.CompExpression_1_0 returns MulExpression
	 *     EquExpression returns MulExpression
	 *     EquExpression.EquExpression_1_0 returns MulExpression
	 *     AddExpression returns MulExpression
	 *     AddExpression.AddExpression_1_0 returns MulExpression
	 *     MulExpression returns MulExpression
	 *     MulExpression.MulExpression_1_0 returns MulExpression
	 *
	 * Constraint:
	 *     (left=MulExpression_MulExpression_1_0 mulOp=MulOperator right=PowerExpression)
	 */
	protected void sequence_MulExpression(ISerializationContext context, MulExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.MUL_EXPRESSION__MUL_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.MUL_EXPRESSION__MUL_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulExpressionAccess().getMulExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulExpressionAccess().getMulOpMulOperatorEnumRuleCall_1_1_0(), semanticObject.getMulOp());
		feeder.accept(grammarAccess.getMulExpressionAccess().getRightPowerExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputVarDeclaration returns OutputVarDeclaration
	 *
	 * Constraint:
	 *     vars+=VarInitDeclaration*
	 */
	protected void sequence_OutputVarDeclaration(ISerializationContext context, OutputVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamAssignmentElements returns ParamAssignmentElements
	 *
	 * Constraint:
	 *     (elements+=ParamAssignment elements+=ParamAssignment*)
	 */
	protected void sequence_ParamAssignmentElements(ISerializationContext context, ParamAssignmentElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamAssignment returns ParamAssignment
	 *
	 * Constraint:
	 *     (variable=[SymbolicVariable|ID] assig=AssignmentType value=Expression)
	 */
	protected void sequence_ParamAssignment(ISerializationContext context, ParamAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.PARAM_ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.PARAM_ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.PARAM_ASSIGNMENT__ASSIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.PARAM_ASSIGNMENT__ASSIG));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.PARAM_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.PARAM_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamAssignmentAccess().getVariableSymbolicVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(PoSTPackage.Literals.PARAM_ASSIGNMENT__VARIABLE, false));
		feeder.accept(grammarAccess.getParamAssignmentAccess().getAssigAssignmentTypeEnumRuleCall_1_0(), semanticObject.getAssig());
		feeder.accept(grammarAccess.getParamAssignmentAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PowerExpression
	 *     Expression.Expression_1_0 returns PowerExpression
	 *     XorExpression returns PowerExpression
	 *     XorExpression.XorExpression_1_0 returns PowerExpression
	 *     AndExpression returns PowerExpression
	 *     AndExpression.AndExpression_1_0 returns PowerExpression
	 *     CompExpression returns PowerExpression
	 *     CompExpression.CompExpression_1_0 returns PowerExpression
	 *     EquExpression returns PowerExpression
	 *     EquExpression.EquExpression_1_0 returns PowerExpression
	 *     AddExpression returns PowerExpression
	 *     AddExpression.AddExpression_1_0 returns PowerExpression
	 *     MulExpression returns PowerExpression
	 *     MulExpression.MulExpression_1_0 returns PowerExpression
	 *     PowerExpression returns PowerExpression
	 *     PowerExpression.PowerExpression_1_0 returns PowerExpression
	 *
	 * Constraint:
	 *     (left=PowerExpression_PowerExpression_1_0 right=UnaryExpression)
	 */
	protected void sequence_PowerExpression(ISerializationContext context, PowerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerExpressionAccess().getPowerExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowerExpressionAccess().getRightUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PrimaryExpression
	 *     Expression.Expression_1_0 returns PrimaryExpression
	 *     XorExpression returns PrimaryExpression
	 *     XorExpression.XorExpression_1_0 returns PrimaryExpression
	 *     AndExpression returns PrimaryExpression
	 *     AndExpression.AndExpression_1_0 returns PrimaryExpression
	 *     CompExpression returns PrimaryExpression
	 *     CompExpression.CompExpression_1_0 returns PrimaryExpression
	 *     EquExpression returns PrimaryExpression
	 *     EquExpression.EquExpression_1_0 returns PrimaryExpression
	 *     AddExpression returns PrimaryExpression
	 *     AddExpression.AddExpression_1_0 returns PrimaryExpression
	 *     MulExpression returns PrimaryExpression
	 *     MulExpression.MulExpression_1_0 returns PrimaryExpression
	 *     PowerExpression returns PrimaryExpression
	 *     PowerExpression.PowerExpression_1_0 returns PrimaryExpression
	 *     UnaryExpression returns PrimaryExpression
	 *     PrimaryExpression returns PrimaryExpression
	 *
	 * Constraint:
	 *     (
	 *         const=Constant | 
	 *         variable=[SymbolicVariable|ID] | 
	 *         array=ArrayVariable | 
	 *         procStatus=ProcessStatusExpression | 
	 *         funCall=FunctionCall | 
	 *         nestExpr=Expression
	 *     )
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatusExpression returns ProcessStatusExpression
	 *
	 * Constraint:
	 *     (process=[Variable|ID] (active?='ACTIVE' | inactive?='INACTIVE' | stop?='STOP' | error?='ERROR'))
	 */
	protected void sequence_ProcessStatusExpression(ISerializationContext context, ProcessStatusExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessVarDeclaration returns ProcessVarDeclaration
	 *
	 * Constraint:
	 *     vars+=ProcessVarInitDeclaration*
	 */
	protected void sequence_ProcessVarDeclaration(ISerializationContext context, ProcessVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessVarInitDeclaration returns ProcessVarInitDeclaration
	 *
	 * Constraint:
	 *     (varList=ProcessVarList process=[Process|ID])
	 */
	protected void sequence_ProcessVarInitDeclaration(ISerializationContext context, ProcessVarInitDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.PROCESS_VAR_INIT_DECLARATION__VAR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.PROCESS_VAR_INIT_DECLARATION__VAR_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.PROCESS_VAR_INIT_DECLARATION__PROCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.PROCESS_VAR_INIT_DECLARATION__PROCESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessVarInitDeclarationAccess().getVarListProcessVarListParserRuleCall_0_0(), semanticObject.getVarList());
		feeder.accept(grammarAccess.getProcessVarInitDeclarationAccess().getProcessProcessIDTerminalRuleCall_2_0_1(), semanticObject.eGet(PoSTPackage.Literals.PROCESS_VAR_INIT_DECLARATION__PROCESS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessVarList returns ProcessVarList
	 *
	 * Constraint:
	 *     (vars+=ProcessVariable vars+=ProcessVariable*)
	 */
	protected void sequence_ProcessVarList(ISerializationContext context, ProcessVarList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns ProcessVariable
	 *     ProcessVariable returns ProcessVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ProcessVariable(ISerializationContext context, ProcessVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Process
	 *     Process returns Process
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             procInVars+=InputVarDeclaration | 
	 *             procOutVars+=OutputVarDeclaration | 
	 *             procInOutVars+=InputOutputVarDeclaration | 
	 *             procProcessVars+=ProcessVarDeclaration | 
	 *             procVars+=VarDeclaration | 
	 *             procTempVars+=TempVarDeclaration
	 *         )* 
	 *         states+=State*
	 *     )
	 */
	protected void sequence_Process(ISerializationContext context, su.nsk.iae.post.poST.Process semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramConfElements returns ProgramConfElements
	 *
	 * Constraint:
	 *     (elements+=ProgramConfElement elements+=ProgramConfElement*)
	 */
	protected void sequence_ProgramConfElements(ISerializationContext context, ProgramConfElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramConfiguration returns ProgramConfiguration
	 *
	 * Constraint:
	 *     (name=ID task=[Task|ID]? program=[Program|ID] args=ProgramConfElements?)
	 */
	protected void sequence_ProgramConfiguration(ISerializationContext context, ProgramConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             progInVars+=InputVarDeclaration | 
	 *             progOutVars+=OutputVarDeclaration | 
	 *             progInOutVars+=InputOutputVarDeclaration | 
	 *             progVars+=VarDeclaration | 
	 *             progTempVars+=TempVarDeclaration | 
	 *             progExternVars+=ExternalVarDeclaration
	 *         )* 
	 *         processes+=Process*
	 *     )
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericLiteral returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     (type=REAL_TYPE_NAME? rSig?='-'? value=REAL)
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RepeatStatement
	 *     IterationStatement returns RepeatStatement
	 *     RepeatStatement returns RepeatStatement
	 *
	 * Constraint:
	 *     (statement=StatementList cond=Expression)
	 */
	protected void sequence_RepeatStatement(ISerializationContext context, RepeatStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.REPEAT_STATEMENT__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.REPEAT_STATEMENT__COND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatStatementAccess().getStatementStatementListParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getRepeatStatementAccess().getCondExpressionParserRuleCall_3_0(), semanticObject.getCond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ResetTimerStatement returns ResetTimerStatement
	 *     Statement returns ResetTimerStatement
	 *
	 * Constraint:
	 *     {ResetTimerStatement}
	 */
	protected void sequence_ResetTimerStatement(ISerializationContext context, ResetTimerStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Resource returns Resource
	 *
	 * Constraint:
	 *     (name=ID type=ID resGlobVars+=GlobalVarDeclaration* resStatement=SingleResource)
	 */
	protected void sequence_Resource(ISerializationContext context, Resource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetStateStatement returns SetStateStatement
	 *     Statement returns SetStateStatement
	 *
	 * Constraint:
	 *     (state=[State|ID] | next?='NEXT')
	 */
	protected void sequence_SetStateStatement(ISerializationContext context, SetStateStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignedInteger returns SignedInteger
	 *
	 * Constraint:
	 *     (iSig?='-'? value=INTEGER)
	 */
	protected void sequence_SignedInteger(ISerializationContext context, SignedInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleSpecificationInit returns SimpleSpecificationInit
	 *
	 * Constraint:
	 *     (type=DataTypeName value=Expression?)
	 */
	protected void sequence_SimpleSpecificationInit(ISerializationContext context, SimpleSpecificationInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleResource returns SingleResource
	 *
	 * Constraint:
	 *     (tasks+=Task | programConfs+=ProgramConfiguration)*
	 */
	protected void sequence_SingleResource(ISerializationContext context, SingleResource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatements returns StartProcessStatement
	 *     StartProcessStatement returns StartProcessStatement
	 *     Statement returns StartProcessStatement
	 *
	 * Constraint:
	 *     process=[Variable|ID]?
	 */
	protected void sequence_StartProcessStatement(ISerializationContext context, StartProcessStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (name=ID looped?='LOOPED'? statement=StatementList timeout=TimeoutStatement?)
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementList returns StatementList
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatements returns StopProcessStatement
	 *     StopProcessStatement returns StopProcessStatement
	 *     Statement returns StopProcessStatement
	 *
	 * Constraint:
	 *     process=[Variable|ID]?
	 */
	protected void sequence_StopProcessStatement(ISerializationContext context, StopProcessStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SubprogramControlStatement
	 *     SubprogramControlStatement returns SubprogramControlStatement
	 *
	 * Constraint:
	 *     {SubprogramControlStatement}
	 */
	protected void sequence_SubprogramControlStatement(ISerializationContext context, SubprogramControlStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns SymbolicVariable
	 *     SymbolicVariable returns SymbolicVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SymbolicVariable(ISerializationContext context, SymbolicVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolicVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TaskInitialization returns TaskInitialization
	 *
	 * Constraint:
	 *     (single=Constant | (interval=Constant priority=INTEGER))
	 */
	protected void sequence_TaskInitialization(ISerializationContext context, TaskInitialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (name=ID init=TaskInitialization)
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.TASK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.TASK__NAME));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.TASK__INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.TASK__INIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTaskAccess().getInitTaskInitializationParserRuleCall_3_0(), semanticObject.getInit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TempVarDeclaration returns TempVarDeclaration
	 *
	 * Constraint:
	 *     vars+=VarInitDeclaration*
	 */
	protected void sequence_TempVarDeclaration(ISerializationContext context, TempVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateProcessAttachVariableConfElement returns TemplateProcessAttachVariableConfElement
	 *
	 * Constraint:
	 *     (programVar=[Variable|ID] assig=AssignmentType (attVar=[Variable|ID] | const=Constant))
	 */
	protected void sequence_TemplateProcessAttachVariableConfElement(ISerializationContext context, TemplateProcessAttachVariableConfElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns TemplateProcessConfElement
	 *     ProgramConfElement returns TemplateProcessConfElement
	 *     TemplateProcessConfElement returns TemplateProcessConfElement
	 *
	 * Constraint:
	 *     (active?='ACTIVE'? name=ID process=[Process|ID] args=TemplateProcessElements?)
	 */
	protected void sequence_TemplateProcessConfElement(ISerializationContext context, TemplateProcessConfElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateProcessElements returns TemplateProcessElements
	 *
	 * Constraint:
	 *     (elements+=TemplateProcessAttachVariableConfElement elements+=TemplateProcessAttachVariableConfElement*)
	 */
	protected void sequence_TemplateProcessElements(ISerializationContext context, TemplateProcessElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeLiteral returns TimeLiteral
	 *
	 * Constraint:
	 *     interval=INTERVAL
	 */
	protected void sequence_TimeLiteral(ISerializationContext context, TimeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.TIME_LITERAL__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.TIME_LITERAL__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeLiteralAccess().getIntervalINTERVALTerminalRuleCall_3_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeoutStatement returns TimeoutStatement
	 *
	 * Constraint:
	 *     ((const=Constant | variable=[SymbolicVariable|ID]) statement=StatementList)
	 */
	protected void sequence_TimeoutStatement(ISerializationContext context, TimeoutStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryExpression
	 *     Expression.Expression_1_0 returns UnaryExpression
	 *     XorExpression returns UnaryExpression
	 *     XorExpression.XorExpression_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.AndExpression_1_0 returns UnaryExpression
	 *     CompExpression returns UnaryExpression
	 *     CompExpression.CompExpression_1_0 returns UnaryExpression
	 *     EquExpression returns UnaryExpression
	 *     EquExpression.EquExpression_1_0 returns UnaryExpression
	 *     AddExpression returns UnaryExpression
	 *     AddExpression.AddExpression_1_0 returns UnaryExpression
	 *     MulExpression returns UnaryExpression
	 *     MulExpression.MulExpression_1_0 returns UnaryExpression
	 *     PowerExpression returns UnaryExpression
	 *     PowerExpression.PowerExpression_1_0 returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (unOp=UnaryOperator right=PrimaryExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.UNARY_EXPRESSION__UN_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.UNARY_EXPRESSION__UN_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getUnOpUnaryOperatorEnumRuleCall_1_0_0(), semanticObject.getUnOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (const?='CONSTANT'? vars+=VarInitDeclaration*)
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarInitDeclaration returns VarInitDeclaration
	 *
	 * Constraint:
	 *     (varList=VarList (spec=SimpleSpecificationInit | arrSpec=ArraySpecificationInit | fb=[FunctionBlock|ID]))
	 */
	protected void sequence_VarInitDeclaration(ISerializationContext context, VarInitDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarList returns VarList
	 *
	 * Constraint:
	 *     (vars+=SymbolicVariable vars+=SymbolicVariable*)
	 */
	protected void sequence_VarList(ISerializationContext context, VarList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     IterationStatement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (cond=Expression statement=StatementList)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.WHILE_STATEMENT__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.WHILE_STATEMENT__COND));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getCondExpressionParserRuleCall_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getWhileStatementAccess().getStatementStatementListParserRuleCall_3_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns XorExpression
	 *     Expression.Expression_1_0 returns XorExpression
	 *     XorExpression returns XorExpression
	 *     XorExpression.XorExpression_1_0 returns XorExpression
	 *
	 * Constraint:
	 *     (left=XorExpression_XorExpression_1_0 right=AndExpression)
	 */
	protected void sequence_XorExpression(ISerializationContext context, XorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
